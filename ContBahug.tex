\documentclass[ignorenonframetext,]{beamer}
\setbeamertemplate{caption}[numbered]
\setbeamertemplate{caption label separator}{:}
\setbeamercolor{caption name}{fg=normal text.fg}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\usepackage{lmodern}
\ifxetex
  \usepackage{fontspec,xltxtra,xunicode}
  \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
  \newcommand{\euro}{€}
\else
  \ifluatex
    \usepackage{fontspec}
    \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
    \newcommand{\euro}{€}
  \else
    \usepackage[T1]{fontenc}
    \usepackage[utf8]{inputenc}
      \fi
\fi
% use upquote if available, for straight quotes in haskellcode environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{\usepackage{microtype}}{}

% Comment these out if you don't want a slide with just the
% part/section/subsection/subsubsection title:
\AtBeginPart{
  \let\insertpartnumber\relax
  \let\partname\relax
  \frame{\partpage}
}
\AtBeginSection{
  \let\insertsectionnumber\relax
  \let\sectionname\relax
  \frame{\sectionpage}
}
\AtBeginSubsection{
  \let\insertsubsectionnumber\relax
  \let\subsectionname\relax
  \frame{\subsectionpage}
}

\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\setcounter{secnumdepth}{0}
\usepackage{minted}
\usemintedstyle{tango}
\newminted{haskell}{mathescape}
\newmintinline{haskell}{}
\setmonofont[Mapping=tex-text,Ligatures={TeX,Common,Contextual},Scale=MatchUppercase]{PragmataPro}
\setsansfont[Mapping=tex-text,Ligatures={TeX,Common,Contextual},Scale=MatchUppercase]{FreightSans Pro}

\title{Continuations in Haskell}
\author{Ryan Orendorff (ryan@rdodesigns.com)}
\date{12 May, 2015}

\begin{document}
\frame{\titlepage}

\begin{frame}{What we are going to cover today}

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  The basics of CPS style
\item
  The \texttt{Cont} monad
\item
  Call with Current Continuation (\texttt{callCC})
\item
  An motivating use case
\end{itemize}

\long\def\ignore\#1\{\}

\ignore{

> module ContBahug where
>
> import Control.Monad.Trans.Class
> import Control.Monad.Trans.Cont
> import Control.Monad

}

\end{frame}

\section{The Basics of CPS Style}\label{the-basics-of-cps-style}

\begin{frame}[fragile]{How do we compute things?}

Computing a value is normally quite simple.

\begin{haskellcode}
type Radius = Double
type Area = Double

areaCircle :: Radius -> Area
areaCircle r = pi * r * r
\end{haskellcode}

\begin{haskellcode}
areaCircle 1 -- $\pi$
\end{haskellcode}

\pause

But what if we have some value (radius/width/etc), but we don't know
what area function to use yet.

\end{frame}

\begin{frame}[fragile]{How do we make a value wait for a function?}

Normally we have a function wait for a value.

\begin{haskellcode}
($) :: (a -> b) -> a -> b
f $ x = f x
\end{haskellcode}

\pause

What if we flip the arguments?

\begin{haskellcode}
(£) :: a -> (a -> b) -> b
(£) = flip ($)
-- or (£) = \x -> (\f -> f x)
\end{haskellcode}

\end{frame}

\begin{frame}[fragile]{Now we can do all sorts of things to the same
radius}

\begin{haskellcode}
type Height = Double; type Volume = Double; type Diameter = Double

volumeCylinder :: Radius -> Height -> Volume
volumeCylinder r h = areaCircle r * h

diameter :: Radius -> Diameter
diameter r = 2*r

doSomethingToR :: (Radius -> r) -> r
doSomethingToR = (1.0 £)
\end{haskellcode}

\pause

\begin{haskellcode}
doSomethingToR areaCircle       -- $\pi$

-- doSomethingToR volumeCylinder :: Height -> Volume
doSomethingToR volumeCylinder 2 -- $2\pi$

doSomethingToR diameter         -- 2
\end{haskellcode}

\end{frame}

\begin{frame}[fragile]{Suspended computation}

\texttt{£} creates what is known as a suspended computation.

\begin{haskellcode}
areaCircle -- Waiting for an input
\end{haskellcode}

\pause

\begin{haskellcode}
areaCircle 1 -- Represents a value
\end{haskellcode}

\pause

\begin{haskellcode}
(1 £) -- Do something to the value 1 later
\end{haskellcode}

\pause

\begin{haskellcode}
(areaCircle 1 £)  -- Wait to do something with the
                  -- result of areaCircle 1
\end{haskellcode}

\pause

\begin{haskellcode}
areaCircle 1 £ id -- Execute `areaCircle 1`,
                  -- pass the result to id
\end{haskellcode}

\end{frame}

\begin{frame}[fragile]{Standard Notation for Suspended Computations}

In the literature/online, you will likely see turning a value into a
suspended computation written as follows.

\begin{haskellcode}
cpsify :: a -> (a -> r) -> r
cpsify x k = k x
-- or cpsify x = \k -> k x
\end{haskellcode}

where

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  \texttt{r} is the final result of evaluating the computation.
\item
  \texttt{a -\textgreater{} r} is what you are doing to do to \texttt{x}
  later. This is represented here as \texttt{k}.
\item
  \texttt{k} is also called the ``continuation'', or ``continue on with
  the value you pass to me''.
\end{itemize}

\end{frame}

\begin{frame}{Currently we can't do much}

We can create suspended computations quite easily using \texttt{cpsify}.
What we really need is something to \emph{chain} our suspended
computations together.

\end{frame}

\begin{frame}[fragile]{Chaining Training Wheels}

Say we have two suspended computations.

\begin{haskellcode}
suspendArea :: Radius -> (Area -> r) -> r
suspendArea r = \k -> k (areaCircle r)

-- Calculate the volume of any extrusion.
suspendExtrude :: Area -> Height -> (Volume -> r) -> r
suspendExtrude a h = \k -> k (a * h)
\end{haskellcode}

\pause

What we would like is something like this

\begin{haskellcode}
suspendVolume :: Radius -> Height -> (Volume -> r) -> r
\end{haskellcode}

\end{frame}

\begin{frame}[fragile]{Chaining Training Wheels}

We could try this.

\begin{haskellcode}
suspendVolume :: Radius -> Height -> (Volume -> r) -> r
suspendVolume r h = \k -> ?    -- k :: (Volume -> r) -> r
\end{haskellcode}

\end{frame}

\begin{frame}[fragile]{Chaining Training Wheels}

We could try this.

\begin{haskellcode}
suspendVolume :: Radius -> Height -> (Volume -> r) -> r
suspendVolume r h = \k ->      -- k :: (Volume -> r) -> r
  suspendArea r                -- needs a (Area -> r)
\end{haskellcode}

\end{frame}

\begin{frame}[fragile]{Chaining Training Wheels}

We could try this.

\begin{haskellcode}
suspendVolume :: Radius -> Height -> (Volume -> r) -> r
suspendVolume r h = \k ->      -- k :: (Volume -> r) -> r
  suspendArea r                -- needs a (Area -> r)
  (\area -> ?)                 -- needs to return r
\end{haskellcode}

\end{frame}

\begin{frame}[fragile]{Chaining Training Wheels}

We could try this.

\begin{haskellcode}
suspendVolume :: Radius -> Height -> (Volume -> r) -> r
suspendVolume r h = \k ->      -- k :: (Volume -> r) -> r
  suspendArea r                -- needs a (Area -> r)
  (\area ->                    -- needs to return r
    suspendExtrude area h ?)   -- needs a (Volume -> r)
\end{haskellcode}

\end{frame}

\begin{frame}[fragile]{Chaining Training Wheels}

We could try this.

\begin{haskellcode}
suspendVolume :: Radius -> Height -> (Volume -> r) -> r
suspendVolume r h = \k ->      -- k :: (Volume -> r) -> r
  suspendArea r                -- needs a (Area -> r)
  (\area ->                    -- needs to return r
    suspendExtrude area h      -- needs a (Volume -> r)
      k)                       -- k is a (Volume -> r)!
\end{haskellcode}

\end{frame}

\begin{frame}[fragile]{\texttt{suspendVolume} seems to work}

We get a suspended computation that calculates the volume and waits for
us to do something with it.

\begin{haskellcode}
suspendVolume 1 2      -- :: (Volume -> r) -> r
suspendVolume 1 2 id   -- $2 \pi$
suspendVolume 1 2 (*2) -- $2 * 2\pi = 4 \pi$
\end{haskellcode}

Let's break it down to make sure we are calculating what we want.

\end{frame}

\begin{frame}[fragile]{Breakdown \texttt{suspendVolume}}

\begin{haskellcode}
-- suspendArea r = \k -> k (areaCircle r)
-- suspendExtrude a h = \k -> k (a * h)
\end{haskellcode}

\begin{haskellcode}
suspendVolume :: Radius -> Height -> (Volume -> r) -> r
suspendVolume r h = \k ->      -- k :: (Volume -> r) -> r
  (suspendArea r)              -- needs a (Area -> r)
  (\area ->                    -- needs to return r
    (suspendExtrude area h)    -- needs a (Volume -> r)
      k)                       -- k is a (Volume -> r)!
\end{haskellcode}

Expand \texttt{suspendArea}.

\end{frame}

\begin{frame}[fragile]{Breakdown \texttt{suspendVolume}}

\begin{haskellcode}
-- suspendArea r = \k -> k (areaCircle r)
-- suspendExtrude a h = \k -> k (a * h)
\end{haskellcode}

\begin{haskellcode}
suspendVolume :: Radius -> Height -> (Volume -> r) -> r
suspendVolume r h = \k ->      -- k :: (Volume -> r) -> r
  (\k -> k (areaCircle r)      -- needs a (Area -> r)
  (\area ->                    -- needs to return r
    (suspendExtrude area h)    -- needs a (Volume -> r)
      k)                       -- k is a (Volume -> r)!
\end{haskellcode}

Evaluate the
\texttt{(\textbackslash{}k -\textgreater{} k (areaCircle r))}.

\end{frame}

\begin{frame}[fragile]{Breakdown \texttt{suspendVolume}}

\begin{haskellcode}
-- suspendArea r = \k -> k (areaCircle r)
-- suspendExtrude a h = \k -> k (a * h)
\end{haskellcode}

\begin{haskellcode}
suspendVolume :: Radius -> Height -> (Volume -> r) -> r
suspendVolume r h = \k ->      -- k :: (Volume -> r) -> r
  (\area ->                    -- needs to return r
    (suspendExtrude area h)    -- needs a (Volume -> r)
      k)                       -- k is a (Volume -> r)!
  (areaCircle r)               -- areaCircle applied to
                               --   \area -> ...
\end{haskellcode}

Substitude in \texttt{area}.

\end{frame}

\begin{frame}[fragile]{Breakdown \texttt{suspendVolume}}

\begin{haskellcode}
-- suspendArea r = \k -> k (areaCircle r)
-- suspendExtrude a h = \k -> k (a * h)
\end{haskellcode}

\begin{haskellcode}
suspendVolume :: Radius -> Height -> (Volume -> r) -> r
suspendVolume r h = \k ->      -- k :: (Volume -> r) -> r
  (suspendExtrude (areaCircle r) h) -- needs (Volume -> r)
      k)                       -- k is a (Volume -> r)!
\end{haskellcode}

Expand \texttt{suspendExtrude}.

\end{frame}

\begin{frame}[fragile]{Breakdown \texttt{suspendVolume}}

\begin{haskellcode}
-- suspendArea r = \k -> k (areaCircle r)
-- suspendExtrude a h = \k -> k (a * h)
\end{haskellcode}

\begin{haskellcode}
suspendVolume :: Radius -> Height -> (Volume -> r) -> r
suspendVolume r h = \k ->      -- k :: (Volume -> r) -> r
  (\k -> k $ (areaCircle r) * h) -- needs (Volume -> r)
      k)                       -- k is a (Volume -> r)!
\end{haskellcode}

Apply k.

\end{frame}

\begin{frame}[fragile]{Breakdown \texttt{suspendVolume}}

\begin{haskellcode}
-- suspendArea r = \k -> k (areaCircle r)
-- suspendExtrude a h = \k -> k (a * h)
\end{haskellcode}

\begin{haskellcode}
suspendVolume' :: Radius -> Height -> (Volume -> r) -> r
suspendVolume' r h = \k ->    -- k :: (Volume -> r) -> r
  k $ areaCircle r * h
\end{haskellcode}

Well that is certainly correct!

\end{frame}

\begin{frame}[fragile]{Manual chaining is suspended rear pain}

We can do better. We have a common pattern here

\begin{haskellcode}
suspendA :: (a -> r) -> r
suspendB :: a -> (b -> r) -> r
suspendA (\a -> (suspendB a) (\b -> ...))
\end{haskellcode}

Let's turn this pattern into a function\footnote{From
  \href{http://en.wikibooks.org/wiki/Haskell/Continuation_passing_style}{The
  Haskell Wikibook}, although there it is called \texttt{chainCPS}}

\begin{haskellcode}
chain :: ((a -> r) -> r) -> (a -> ((b -> r) -> r)) ->
         ((b -> r) -> r)
\end{haskellcode}

\pause

\begin{haskellcode}
chain sA aTosB = \k -> -- k :: (b -> r)
  sA                   -- needs a (a -> r)
  (\a ->
    aTosB a            -- needs a (b -> r)
     k)                -- k is a (b -> r)!
\end{haskellcode}

\end{frame}

\begin{frame}[fragile]{Making \texttt{suspendVolume} is much easier now}

\begin{haskellcode}
-- suspendArea r = \k -> k (areaCircle r)
-- Flip arguments to chain easier.
suspendExtrude' :: Height -> Area -> (Volume -> r) -> r
suspendExtrude' h a = suspendExtrude a h

suspendVolume'' :: Radius -> Height -> (Volume -> r) -> r
suspendVolume'' r h = suspendArea r `chain`
                      suspendExtrude' h
\end{haskellcode}

\begin{haskellcode}
-- chain for us looks like
chain :: ((Area -> r) -> r) -> (Area -> ((Volume -> r) -> r)) ->
         ((Volume -> r) -> r)
\end{haskellcode}

\end{frame}

\begin{frame}[fragile]{I smell a monadic burrito
(\href{http://blog.plover.com/prog/burritos.html}{link})}

\texttt{cpsify} (or \texttt{(£)}) is acting like \texttt{return}, and
\texttt{chain} is acting like \texttt{bind}
(\texttt{(\textgreater{}\textgreater{}=)}). Lets make a type for these
suspended computations then.

\begin{haskellcode}
-- Already defined in Control.Monad.Trans.Cont
newtype Cont r a = Cont {runCont :: (a -> r) -> r}
\end{haskellcode}

\pause

\begin{haskellcode}
instance Monad (Cont r) where
    return :: a -> Cont r a
    return x = Cont (\k -> k x)
 -- cpsify x =       \k -> k x
\end{haskellcode}

\pause

\begin{haskellcode}
    (>>=) :: Cont r a -> (a -> Cont r b) -> Cont r b
    m >>= f = Cont
        (\k -> runCont m (\a -> runCont (f a) k))
 -- chain m f = \k ->  m (\a ->         (f a) k)
\end{haskellcode}

\end{frame}

\section{The \texttt{Cont} monad}\label{the-cont-monad}

\begin{frame}[fragile]{\texttt{do} sweetness is now possible}

\texttt{Cont} is a monad, which means we can get some nice \texttt{do}
syntactic sugar.

\begin{haskellcode}
-- Control.Monad.Trans.Cont exports cont, not Cont
cont = Cont
\end{haskellcode}

\begin{haskellcode}
suspendAreaCont :: Radius -> Cont r Area
suspendAreaCont r = cont (\k -> k (areaCircle r))

suspendExtrudeCont :: Height -> Area -> Cont r Volume
suspendExtrudeCont h a = cont (\k -> k (a * h))

suspendVolumeCont :: Radius -> Height -> Cont r Volume
suspendVolumeCont r h = do
  area <- suspendAreaCont r
  suspendExtrudeCont h area
\end{haskellcode}

\end{frame}

\begin{frame}[fragile]{What happens if we forget the k?}

The \texttt{k} in the prior functions represented ``the rest of the
computation''. So what happens when we forget the k?

\begin{haskellcode}
-- I wonder where the r went....
suspendAreaOops :: Double -> Cont Double Double
suspendAreaOops r = cont (\_ -> areaCircle r)

suspendVolumeOops :: Radius -> Height -> Cont Double Double
suspendVolumeOops r h = do
  area <- suspendAreaOops r
  suspendExtrudeCont h area
\end{haskellcode}

What is the result of the following?

\begin{haskellcode}
oops :: Double
oops = runCont (suspendVolumeOops 1 2) id
\end{haskellcode}

\pause

\begin{haskellcode}
-- oops == $\pi$
-- (wait, that is not $(\pi * 1^2) * 2 = 2*\pi$)
\end{haskellcode}

\end{frame}

\begin{frame}[fragile]{The \texttt{k} meant ``keep going!''}

Normally we have this kind of scenario.

\begin{haskellcode}
area -> extrude -> suspended computation
--        or (area -> ((extrude -> suspended computation))
--  k is "conceptually" ^------------------------------^
\end{haskellcode}

When we did not call \texttt{k}, we forgot to keep going forward and
instead did this.

\begin{haskellcode}
area -> suspended computation
\end{haskellcode}

\end{frame}

\begin{frame}[fragile]{What happens if we double the use of k?}

\begin{haskellcode}
suspendAreaDbl :: Radius -> Cont [r] Area
suspendAreaDbl r = cont (\k -> k (areaCircle r) ++
                               k (areaCircle (r + 2)))

suspendVolumeDbl :: Radius -> Height -> Cont [r] Volume
suspendVolumeDbl r h = do
  area <- suspendAreaDbl r
  suspendExtrudeCont h area
\end{haskellcode}

What is the result of the following?

\begin{haskellcode}
dbl :: [Volume]
dbl = runCont (suspendVolumeDbl 1 2) return
\end{haskellcode}

\pause

\begin{haskellcode}
-- dbl = [6.283185307179586,56.548667764616276]
-- dbl = [$2 \pi$] ++ [$18 \pi$]
\end{haskellcode}

We execute the remaining computation twice, and throw the result into
\texttt{\textbackslash{}k -\textgreater{} k (areaCircle r) ++ k (areaCircle (r + 2))}

\end{frame}

\begin{frame}{What do we currently have?}

We have a few tools to make suspended computations.

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  A way to create suspended computations (\texttt{cpsify} or
  \texttt{return})
\item
  A way to chain those computations (\texttt{chain} or
  \texttt{(\textgreater{}\textgreater{}=)})
\item
  All of this wrapped in a type \texttt{Cont r a}
\end{itemize}

In addition, we have seen how to break out of the standard control flow.

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Forget \texttt{k}: do not process any more lines in the continuation.
\item
  Use \texttt{k} twice: repeat the continuation twice, combine results.
\end{itemize}

\end{frame}

\section{Call with Current Continuation
(\texttt{callCC})}\label{call-with-current-continuation-callcc}

\begin{frame}{What else could we want?}

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  We have a way to stop what we were doing (forget \texttt{k})
\item
  We have a way to ``branch'' (use \texttt{k}) twice
\item
  We didn't talk about it but if \texttt{k :: (r -\textgreater{} r)}
  then we can run a function on itself again
  (\texttt{\textbackslash{}k -\textgreater{} k (k (...))})
\end{itemize}

Once we are in \texttt{Cont}, using \texttt{k} is somewhat tedious (it
needs to be explicitly brought out).

\end{frame}

\begin{frame}{An eject button would be nice}

What if we brought out \texttt{k} only when we needed it? Where k is
``skip whatever else we were going to do in this continuation and keep
going with the next one''.

\end{frame}

\begin{frame}[fragile]{Ejecting with \texttt{callCC}}

There is a function that does this called ``call with current
continuation'', or \texttt{callCC} in Haskell.

\begin{haskellcode}
callCC :: ((a -> Cont r b) -> Cont r a) -> Cont r a

calc :: Double -> Double -> String
calc a b = (`runCont` id) $ do

  ans <- callCC $ \eject -> do
           c <- return $ a*2 + b + 3
           when (c == 0) (eject "oops dividing by 0")
           d <- return $ a + b
           return $ show (d / c)

  return $ "Answer: " ++ ans
\end{haskellcode}

\end{frame}

\begin{frame}[fragile]{Ejecting with \texttt{callCC}}

There is a function that does this called ``call with current
continuation'', or \texttt{callCC} in Haskell.

\begin{haskellcode}
callCC :: ((a -> Cont r b) -> Cont r a) -> Cont r a

calc :: Double -> Double -> String
calc a b = (`runCont` id) $ do

  --  |-- Calling `eject` is the same as
  --  v   `ans <- return "oops dividing by 0"`
  ans <- callCC $ \eject -> do
           c <- return $ a*2 + b + 3
           when (c == 0) (eject "oops dividing by 0")
           d <- return $ a + b
           return $ show (d / c)

  return $ "Answer: " ++ ans
\end{haskellcode}

\end{frame}

\begin{frame}[fragile]{Ejecting with \texttt{callCC}}

There is a function that does this called ``call with current
continuation'', or \texttt{callCC} in Haskell.

\begin{haskellcode}
callCC :: ((a -> Cont r b) -> Cont r a) -> Cont r a
\end{haskellcode}

\begin{haskellcode}
calc :: Double -> Double -> String
calc a b = (`runCont` id) $ do

  --  |-- `eject` is often called `k`; `k` is the same as
  --  v   `ans <- return "oops dividing by 0"`
  ans <- callCC $ \k -> do
           c <- return $ a*2 + b + 3
           --             k :: String -> Cont String ()
           when (c == 0) (k "oops dividing by 0")
           d <- return $ a + b
           -- String -> Cont String String
           return $ show (d / c)

  return $ "Answer: " ++ ans
\end{haskellcode}

\end{frame}

\begin{frame}[fragile]{Guess the answers}

What happens when we call \texttt{calc}

\begin{haskellcode}
calc :: Double -> Double -> String
calc a b = (`runCont` id) $ do

  ans <- callCC $ \k -> do
           c <- return $ a*2 + b + 3
           when (c == 0) (k "oops dividing by 0")
           d <- return $ a + b
           return $ show (d / c)

  return $ "Answer: " ++ ans
\end{haskellcode}

\begin{haskellcode}
calc_1 = calc 1 2    -- ?
\end{haskellcode}

\end{frame}

\begin{frame}[fragile]{Guess the answers}

What happens when we call \texttt{calc}

\begin{haskellcode}
calc :: Double -> Double -> String
calc a b = (`runCont` id) $ do

  ans <- callCC $ \k -> do
           c <- return $ a*2 + b + 3
           when (c == 0) (k "oops dividing by 0")
           d <- return $ a + b
           return $ show (d / c)

  return $ "Answer: " ++ ans
\end{haskellcode}

\begin{haskellcode}
calc_1 = calc 1 2    -- "Answer: 0.42857142857142855"
\end{haskellcode}

\end{frame}

\begin{frame}[fragile]{Guess the answers}

What happens when we call \texttt{calc}

\begin{haskellcode}
calc :: Double -> Double -> String
calc a b = (`runCont` id) $ do

  ans <- callCC $ \k -> do
           c <- return $ a*2 + b + 3
           when (c == 0) (k "oops dividing by 0")
           d <- return $ a + b
           return $ show (d / c)

  return $ "Answer: " ++ ans
\end{haskellcode}

\begin{haskellcode}
calc_1 = calc 1 2    -- "Answer: 0.42857142857142855"
calc_2 = calc 0 (-3) -- ?
\end{haskellcode}

\end{frame}

\begin{frame}[fragile]{Guess the answers}

What happens when we call \texttt{calc}

\begin{haskellcode}
calc :: Double -> Double -> String
calc a b = (`runCont` id) $ do

  ans <- callCC $ \k -> do
           c <- return $ a*2 + b + 3
           when (c == 0) (k "oops dividing by 0")
           d <- return $ a + b
           return $ show (d / c)

  return $ "Answer: " ++ ans
\end{haskellcode}

\begin{haskellcode}
calc1 :: String
calc1 = calc 1 2    -- "Answer: 0.42857142857142855"
\end{haskellcode}

\begin{haskellcode}
calc2 :: String
calc2 = calc 0 (-3) -- "Answer: oops dividing by 0"
\end{haskellcode}

\end{frame}

\begin{frame}[fragile]{Passing k around}

Shortcutting is useful when we realize that \emph{there is nothing more
to do}. For example, the product of a list containing \texttt{0} is
\texttt{0}.\footnote{From the Haskell Wiki
  \href{https://wiki.haskell.org/Library/CC-delcont}{delcont} page}

\begin{haskellcode}
prod :: (Eq a, Num a) => [a] -> a
prod l = (`runCont` id) $ callCC (\k -> loop k l)
 where
   loop _ []     = return 1
   loop k (0:_)  = k 0
   loop k (x:xs) = do
       n <- loop k xs
       return (n*x)
\end{haskellcode}

\end{frame}

\begin{frame}[fragile]{Passing k around}

Shortcutting is useful when we realize that \emph{there is nothing more
to do}. For example, the product of a list containing \texttt{0} is
\texttt{0}.\footnote{From the Haskell Wiki
  \href{https://wiki.haskell.org/Library/CC-delcont}{delcont} page}

\begin{haskellcode}
prod :: (Eq a, Num a) => [a] -> a
prod l = (`runCont` id) $ callCC (\k -> loop k l)
 where
   loop _ []     = return 1
   loop k (0:_)  = k 0
   loop k (x:xs) = do
       n <- loop k xs
       return (n*x)
\end{haskellcode}

\begin{haskellcode}
prod [1, 2, 3, 4]    -- ?
\end{haskellcode}

\end{frame}

\begin{frame}[fragile]{Passing k around}

Shortcutting is useful when we realize that \emph{there is nothing more
to do}. For example, the product of a list containing \texttt{0} is
\texttt{0}.\footnote{From the Haskell Wiki
  \href{https://wiki.haskell.org/Library/CC-delcont}{delcont} page}

\begin{haskellcode}
prod :: (Eq a, Num a) => [a] -> a
prod l = (`runCont` id) $ callCC (\k -> loop k l)
 where
   loop _ []     = return 1
   loop k (0:_)  = k 0
   loop k (x:xs) = do
       n <- loop k xs
       return (n*x)
\end{haskellcode}

\begin{haskellcode}
prod [1, 2, 3, 4]    -- 24
\end{haskellcode}

\end{frame}

\begin{frame}[fragile]{Passing k around}

Shortcutting is useful when we realize that \emph{there is nothing more
to do}. For example, the product of a list containing \texttt{0} is
\texttt{0}.\footnote{From the Haskell Wiki
  \href{https://wiki.haskell.org/Library/CC-delcont}{delcont} page}

\begin{haskellcode}
prod :: (Eq a, Num a) => [a] -> a
prod l = (`runCont` id) $ callCC (\k -> loop k l)
 where
   loop _ []     = return 1
   loop k (0:_)  = k 0
   loop k (x:xs) = do
       n <- loop k xs
       return (n*x)
\end{haskellcode}

\begin{haskellcode}
prod [1, 2, 3, 4]    -- 24
prod [1, 2, 0, 3, 4] -- ?
\end{haskellcode}

\end{frame}

\begin{frame}[fragile]{Passing k around}

Shortcutting is useful when we realize that \emph{there is nothing more
to do}. For example, the product of a list containing \texttt{0} is
\texttt{0}.\footnote{From the Haskell Wiki
  \href{https://wiki.haskell.org/Library/CC-delcont}{delcont} page}

\begin{haskellcode}
prod :: (Eq a, Num a) => [a] -> a
prod l = (`runCont` id) $ callCC (\k -> loop k l)
 where
   loop _ []     = return 1
   loop k (0:_)  = k 0
   loop k (x:xs) = do
       n <- loop k xs
       return (n*x)
\end{haskellcode}

\begin{haskellcode}
prod [1, 2, 3, 4]    -- 24
prod [1, 2, 0, 3, 4] -- 0 by shortcut
\end{haskellcode}

\end{frame}

\begin{frame}{What we have done so far}

\begin{itemize}
\item
  We have a way to stop what we were doing (forget \texttt{k})
\item
  We have a way to ``branch'' (use \texttt{k}) twice
\item
  We didn't talk about it but if \texttt{k :: (r -\textgreater{} r)}
  then we can run a function on itself again
  (\texttt{\textbackslash{}k -\textgreater{} k (k (...))})
\item
  We can eject from a function (\texttt{callCC})
\end{itemize}

\end{frame}

\begin{frame}{What you can build with continuations}

Lots of different control structures, including

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Exceptions
\item
  Coroutines
\item
  Generators/Iterators
\end{itemize}

\end{frame}

\section{Thanks}\label{thanks}

\begin{frame}[allowframebreaks]{References}

All bullets are clockable links.

Tutorials

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  \href{http://blog.sigfpe.com/2008/12/mother-of-all-monads.html}{The
  Mother of all Monads}
\item
  \href{http://en.wikibooks.org/wiki/Haskell/Continuation_passing_style}{Continuation
  Passing Style: Haskell Wikibooks}
\item
  \href{http://www.codejury.com/continuations-in-haskell/}{Continuations
  in Haskell}
\item
  \href{http://www.haskellforall.com/2012/12/the-continuation-monad.html}{Haskell
  for All: The Continuation Monad} (on modular development using
  continuations and sum types)
\item
  \href{https://www.fpcomplete.com/user/jwiegley/understanding-continuations}{Understanding
  Continuations} (this one can be a bit tricky for new Haskell users).
\item
  \href{http://stackoverflow.com/questions/20536700/understanding-haskell-callcc-examples}{Understanding
  the callCC example in above}
\end{itemize}

CallCC

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  \href{http://stackoverflow.com/questions/9050725/call-cc-implementation}{call/cc
  implementation StackOverflow}
\item
  \href{http://rigaux.org/language-study/various/callcc/scheme.html}{Example
  callCC usage} (in Scheme)
\item
  \href{http://repository.readscheme.org/ftp/papers/PLoP2001_dferguson0_1.pdf}{callCC
  patterns} (in Scheme)
\end{itemize}

Real World Use

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  \href{http://www.serpentine.com/blog/2011/02/25/cps-is-great-cps-is-terrible/}{CPS
  is great! CPS is terrible!} (on the use in attoparsec)
\end{itemize}

Delimited Continuations

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  \href{http://okmij.org/ftp/continuations/Haskell-tutorial.pdf}{Delimited
  Continuations in Haskell tutorial}
\item
  \href{http://okmij.org/ftp/continuations/ContExample.hs}{Example code
  for delimited continuations in haskell}
\item
  \href{https://wiki.haskell.org/Library/CC-delcont}{Library CC-delcont
  examples}
\item
  \href{https://www.youtube.com/watch?v=uN3hyzywzZk}{Delimited
  Continuations and co-monads video}
\end{itemize}

\end{frame}

\section{Extra Code}\label{extra-code}

\begin{frame}[fragile]{Set Example}

We can define sets as a list with a careful insertion function.

\begin{haskellcode}
newtype Set a = Set {getSet :: [a]} deriving (Show)

empty :: Set a
empty = Set []

insert :: Eq a => Set a -> a -> Set a
insert   (Set [])     x = Set [x]
insert s@(Set (y:ys)) x = if x == y
                      then s
                      else Set $ y : getSet (insert (Set ys) x)
\end{haskellcode}

What is problematic when \texttt{insert} is given a value already in the
set?

(Modified problem from Okasaki's ``Purely Functional Data Structures'',
problem 2.3)

\end{frame}

\begin{frame}[fragile]{\texttt{insert} allocates unneeded nodes}

Given a set \texttt{s}.

\begin{haskellcode}
s = a : b : c : d : e : f : []
\end{haskellcode}

\end{frame}

\begin{frame}[fragile]{\texttt{insert} allocates unneeded nodes}

Given a set \texttt{s}.

\begin{haskellcode}
s = a : b : c : d : e : f : []
                ^------------^
                         |
insert s d = a : b : c : |
\end{haskellcode}

\texttt{insert} allocates a (mostly) new \texttt{Set}.

\end{frame}

\begin{frame}[fragile]{A ``smarter'' \texttt{insert}}

Let's use a continuation to return \texttt{s} when \texttt{x} is in
\texttt{s}.

\begin{haskellcode}
insert' :: Eq a => Set a -> a -> Set a
insert' s' x = (`runCont` id) $ callCC (\k -> insertShortcut k s')
    where
        insertShortcut _ (Set [])     = return $ Set [x]
        insertShortcut k (Set (y:ys)) =
            if x == y
                then k s'
                else insertShortcut k >=> setcons y $ Set ys

        setcons y (Set ys) = return $ Set (y : ys)
\end{haskellcode}

\end{frame}

\begin{frame}[fragile]{\texttt{insert'} uses less memory}

Given a set \texttt{s}.

\begin{haskellcode}
s = a : b : c : d : e : f : []
    ^------------------------^
              |
insert' s d = |
\end{haskellcode}

\texttt{insert'} returns the same \texttt{s} if an element \texttt{x} is
in \texttt{s}.

\end{frame}

\begin{frame}[fragile]

\begin{haskellcode}
{---------------------
-  Testing with IO  -
---------------------}

io1 :: Int -> ContT () IO String
io1 x = ContT $ \k -> do
    putStrLn "io1 start"
    k $ show x
    putStrLn "io1 end"

io2 :: String -> ContT () IO String
io2 s = ContT $ \k -> do
    putStrLn "io2 start"
    k (s ++ " io2")
    putStrLn "io2 end"

ioExample :: Int -> ContT () IO String
ioExample = io1 >=> io2
\end{haskellcode}

\end{frame}

\begin{frame}[fragile]

From the ``Understanding Continuations'' FP article.

\begin{haskellcode}
fpExample :: IO ()
fpExample = flip runContT return $ do
    lift $ putStrLn "alpha"
    (k, num) <- callCC $ \k -> let f x = k (f, x)
                               in return (f, 0 :: Integer)
    lift $ putStrLn "beta"          -- k
    lift $ putStrLn "gamma"         -- j
    if num < 5
        then void (k (num + 1))
        else lift $ print num       -- l
\end{haskellcode}

\end{frame}

\end{document}
